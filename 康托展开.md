### 康托展开
-----
X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0! 其中，a[i]为整数，并且X=a[n]*(n-1)!+a[n-1]*(n-2)!+...+a[i]*(i-1)!+...+a[1]*0!。这就是康托展开。

a[n]代表的是元素所在的排序（从0 开始）

{1,2,3,4,...,n}表示1,2,3,...,n的排列如 {1,2,3} 按从小到大排列一共6个。123 132 213 231 312 321 。

代表的数字 1 2 3 4 5 6 也就是把10进制数与一个排列对应起来。 

他们间的对应关系可由康托展开来找到。 

如我想知道321是{1,2,3}中第几个大的数可以这样考虑 ： 

第一位是3，当第一位的数小于3时，那排列数小于321 如 123、 213 ，小于3的数有1、2 。所以有2*2!个。再看小于第二位2的：小于2的数只有一个就是1 ，所以有1*1!=1 所以小于321的{1,2,3}排列数有2*2!+1*1!=5个。所以321是第6个大的数。 2*2!+1*1!是康托展开。

再举个例子：1324是{1,2,3,4}排列数中第几个大的数：第一位是1小于1的数没有，是0个 0*3! 第二位是3小于3的数有1和2，但1已经在第一位了，所以只有一个数2 1*2! 。第三位是2小于2的数是1，但1在第一位，所以有0个数 0*1! ，所以比1324小的排列有0*3!+1*2!+0*1!=2个，1324是第三个大数。


~~~ c
#include<stdio.h>
#define Max 100
 
int factorial_function(int num)		//求阶乘
{
	if(num <= 1)
		return 1;
	else
		return (factorial_function(num-1)*num);
}
 
int main()
{
	int num[Max];
	char s[Max];
	int i=0,j=0,k=0,count=0;
	char val;
	int sum = 0;
 
	while(scanf("%c",&val))	//获取元素，如 A C B D 或 1324 
	{
		if(val == '\n')
			break;
		else
		{
			s[count] = val;
			count ++;
		}
	}
 
	//printf("count = %d\n",count);
 
	
	for(i=0;i<count;i++)	// 分别求得元素的排序，如第一个元素需要和剩下的n-1个比较，
	{						//第二个元素需要和剩下的n-2个比较，第三个元素需要和剩下的n-3个元素进行比较等等
		//printf("*************************%c************************\n",s[i]);
		for(j=i+1;j<count;j++)
		{
			if(s[i]>s[j])
			{
				//printf("位置%d: %c > %c\n",j,s[i],s[j]);
				k ++;	 
			}
			
		}
		//printf("%d\n",k);
		num[i] = k;		//有几个数比当前元素小
		k = 0;
	}
	
	for(j=count-1;j>=0;j--)		//输出结果 
	{
		sum += factorial_function(j) * num[k];
		//printf("%d:%d = %d*%d\n",k,sum,factorial_function(j),num[k]);
		k++;
		//printf("%c",s[k++]);
	}
	printf("是第%d大数\n",sum+1);
 
	return 0;
}
~~~
